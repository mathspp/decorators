# 🧠 Section 1 – Why Decorators Matter

**Target duration**: 40–60 minutes
**Purpose**: Introduce the decorator pattern in context by motivating it from first principles. Build foundational understanding of functional patterns, higher-order functions, and closures, setting the stage for decorators later.
**Assumed knowledge**: Functions, imports, basic control flow.

---

## 🎥 Lesson 1. Introduction – What This Course Will Teach You

**Goal**: Give learners context and motivation.

**Content**:

* Briefly define what a decorator is in one sentence (e.g. “a way to wrap a function with extra behavior”).
* Explain that the course will teach:

  * Why decorators are useful
  * How to write them from scratch
  * How to handle advanced use cases
  * How to read and understand decorator-heavy code in real-world projects
* Set expectations:

  * Each video is short and focused
  * Exercises will be written in a separate reference (link to it)
  * There will be some "solve together" videos
  * No prior knowledge of decorators required
  * Beginners can follow the whole course; intermediate devs might want to skip ahead (but shouldn’t!)

**Call to action**: Encourage learners to follow along with the exercises and open the reference in a browser/tab.

---

## 🎥 Lesson 2. The Problem: A Function That Did Too Much

*(based on “A function that did too much”)*

**Goal**: Show how function logic can get cluttered with unrelated behavior (e.g. caching), and how this motivates abstraction.

**Concepts**:

* Single-responsibility principle (lightly)
* “Orthogonal behavior” (define and give examples)
* Motivation for separation of concerns

**Flow**:

1. Start with the simple `factorial(n)` implementation.
2. Show how caching logic clutters the function.
3. Discuss how that logic is useful, but not part of “what factorial means.”
4. Show how the cache is tied to the function but hard to reuse.
5. Mention that this is the kind of problem decorators help solve — but don't introduce them yet. Just tease it.

**Example**: Show the cached version of `factorial(n)` using a dictionary in the function body.

**End note**: “What if we want to reuse this caching logic elsewhere? Let's start thinking in that direction.”

---

## 🎥 Lesson 3. Wrapping Functions Without Changing Them

*(from “Factoring out the orthogonal behaviour”)*

**Goal**: Introduce the pattern of writing wrapper functions without modifying the original.

**Concepts**:

* Higher-order functions (implied)
* Reusability of logic
* Function references

**Flow**:

1. Remove caching from `factorial`.
2. Introduce a `cached_factorial` function that wraps `factorial`.
3. Point out that this works even if we use `math.factorial` — so we can decorate functions we didn’t write.
4. Do the same thing for `fibonacci`.
5. Highlight how the logic is duplicated.

**Key phrase**: “We’re wrapping a function, not changing it. This pattern shows up a lot.”

---

## 🎥 Lesson 4. Duplicated Logic: Time to Generalise

**Goal**: Refactor repeated cache wrappers into a reusable factory.

**Concepts**:

* Code duplication
* Parameterizing behavior via functions
* Function factories

**Flow**:

1. Show the similar code between `cached_factorial` and `cached_fibonacci`.
2. Create `cached_factory(f)` and walk through what it returns.
3. Use it to build both `cached_factorial` and `cached_fibonacci`.

**Example**: Time the calls to show the cache is working.

**End note**: “We’re on the right track — we now have a reusable function that adds behavior to other functions.”

---

## 🎥 Lesson 5. Closure Mechanics Explained

*(This appears earlier than in the blog for clarity.)*

**Goal**: Explain *why* the caching continues to work — closures.

**Concepts**:

* Closures
* Lexical scope
* The “bubble” analogy

**Flow**:

1. Define what a closure is in Python (function + environment).
2. Explain that `cache` and `f` persist inside the returned function.
3. Show how you can access the closure cells to peek at the internal cache (briefly — not required knowledge).
4. Tie it to real-world intuition: “this function remembers stuff.”

**Call-out**: “Understanding closures is key to building decorators later.”

---

## 📘 Lesson 6. First Exercise Break (self-guided)

**Goal**: Give learners a chance to solidify the basic function factory idea.

**Instructions (in the written reference)**:

* Re-implement `cached_factorial` using `cached_factory`.
* Implement a cache for another recursive function, like a naïve power function.
* Add timing manually to see the benefit.

**Mention**: “We’ll soon build a factory for timing too.”

---

## 🎥 Lesson 7. Solve Together: Build a Simple Cache Decorator

**Goal**: Reinforce learning by walking through a function factory again, and foreshadow decorators.

**Flow**:

1. Prompt: “Let’s build a cache decorator together — no @ yet.”
2. Code out a simplified `cache(f)` that returns a wrapper.
3. Add a dictionary.
4. Apply it to a new function (e.g. `square(n)`) to test.
5. Print timings or function output to show it’s working.

**Wrap-up**: “This pattern — function in, function out — is at the heart of decorators.”

---

## ✅ Section Summary

By the end of this section, the learner:

* Understands the motivation behind decorators
* Has written higher-order functions
* Understands closures in practice
* Can build reusable behavior wrappers
* Is ready to see the `@` decorator syntax in action

---

Shall I proceed to Section 2, or would you like to adjust or expand anything in Section 1?
