# üß± Section 2 ‚Äì From Higher-Order Functions to Decorators

**Target duration**: 45‚Äì60 minutes
**Purpose**: Bridge the gap between function factories and official Python decorator syntax. Make learners comfortable with the `@` symbol, and give them hands-on practice converting function wrappers into decorators.
**Assumed knowledge**: Everything from Section 1 ‚Äî higher-order functions, closures, reusable wrappers.

---

## üé• Lesson 1. The Decorator Pattern and Its Syntax

*(based on ‚ÄúThe decorator pattern‚Äù)*

**Goal**: Show how the pattern the learner has been using is formalized in Python as the *decorator pattern*, and introduce the `@` syntax.

**Concepts**:

* Definition of the ‚Äúdecorator pattern‚Äù in software design
* Python's syntactic sugar for decorators

**Flow**:

1. State: ‚ÄúWhat we‚Äôve been doing is the *decorator pattern*.‚Äù
2. Define a decorator as a function that takes a function and returns a function.
3. Show how to use a decorator manually:

   ```python
   fibonacci = cache(fibonacci)
   ```
4. Show equivalent `@` syntax:

   ```python
   @cache
   def fibonacci(...):
   ```
5. Emphasize: This is just sugar ‚Äî the core concept hasn‚Äôt changed.

**Tip**: Mention that the `@` syntax applies at *definition time*, not at runtime.

---

## üé• Lesson 2. Applying Decorators with and without `@`

**Goal**: Give learners fluency in the two ways to apply decorators ‚Äî and when to use each.

**Concepts**:

* `@decorator` vs `f = decorator(f)`
* When you can/cannot use `@`

**Flow**:

1. Revisit `fibonacci` and apply `@cache` to it.
2. Show how you can‚Äôt use `@` if you don‚Äôt define the function (e.g. if you import it).
3. Demonstrate:

   ```python
   from math import factorial
   factorial = cache(factorial)
   ```
4. Emphasize: both approaches are identical in effect.

**Closing note**: ‚ÄúFrom now on, we‚Äôll mostly use the `@` syntax for clarity.‚Äù

---

## üé• Lesson 3. Decorator Mindset: Enhancing Orthogonal Functionality

**(Deviation: This concept is pulled out as its own lesson for clarity.)**

**Goal**: Cement the core purpose of decorators ‚Äî adding orthogonal functionality cleanly.

**Concepts**:

* Orthogonal behavior = not core to function's goal but still useful
* Examples of such behavior: caching, logging, timing, validation, etc.

**Flow**:

1. Define ‚Äúorthogonal‚Äù in simple terms.
2. Give examples of functionality often added via decorators.
3. Tie it to SOLID principles (lightly) ‚Äî single responsibility.
4. Show how decorators help write cleaner, more reusable code.

**Optional**: List a few decorators learners may have seen (`@staticmethod`, `@property`, `@app.route`, etc).

**Wrap-up**: ‚ÄúYou now know the *why* behind decorators ‚Äî the *how* comes next.‚Äù

---

## üìò Lesson 4. Exercise Break: Reimplement and Apply Cache and Timed Decorators

**Goal**: Encourage recall and hands-on practice with both decorators.

**Instructions (in the written reference)**:

* Implement a general `@cache` decorator using `*args`.
* Implement a general `@timed` decorator.
* Apply both to new functions (e.g. a slow prime checker or recursive exponentiation).
* Try stacking them ‚Äî does the order matter?

**Bonus exercise**: Implement a decorator that logs every call to a function.

---

## üé• Lesson 5. Solve Together: Decorate Fibonacci and Benchmark It

**Goal**: Cement the idea of decorating functions in the wild.

**Flow**:

1. Re-implement a recursive `fibonacci`.
2. Apply `@cache` and time its execution.
3. Add `@timed` on top or below ‚Äî demonstrate effect of decorator order.
4. Print results and performance.

**Concepts**:

* Decorator stacking
* Order of evaluation

**Bonus tip**: Explain that decorator stacking reads ‚Äúbottom-up‚Äù:

```python
@a
@b
def f(): ...
```

becomes `f = a(b(f))`.

---

## ‚úÖ Section Summary

By the end of this section, the learner:

* Understands what decorators are formally
* Can use the `@` syntax with confidence
* Can manually apply decorators to existing functions
* Can stack decorators and understand the order of application
* Knows when to use decorators for orthogonal enhancements

---

Shall we move on to Section 3, or would you like to revise anything in Section 2?
