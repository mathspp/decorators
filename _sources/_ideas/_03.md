# 🛠️ Section 3 – Writing General and Useful Decorators

**Target duration**: 60–75 minutes
**Purpose**: Make decorators practical and flexible by introducing `*args` and `**kwargs`, the general “decorator blueprint,” and the `functools.wraps` helper.
**Assumed knowledge**: Familiarity with `@` decorator syntax and single-argument wrappers from Section 2.

---

## 🎥 Lesson 1. Why `*args` and `**kwargs` Are Essential

*(based on “Implementing general decorators”)*

**Goal**: Highlight the limitations of non-general decorators and introduce variadic arguments as the solution.

**Concepts**:

* `*args`, `**kwargs`
* Argument flexibility
* Tuples and dictionaries under the hood

**Flow**:

1. Begin with a function that takes multiple arguments (e.g. `combinations_len(n, r)`).
2. Show how a single-argument decorator fails to decorate it.
3. Ask: “Why doesn’t this work?”
4. Introduce `*args` and `**kwargs` as the answer — a way to pass through *any* arguments.

**Optional**: Demonstrate basic `print(args, kwargs)` output to build intuition.

---

## 🎥 Lesson 2. Refactoring the Cache Decorator

**Goal**: Update the cache decorator to support any arguments using `*args`.

**Concepts**:

* Forwarding arguments
* Tuples as keys for caching

**Flow**:

1. Take the previously written one-arg cache decorator.
2. Replace the parameter list with `*args`.
3. Update the call to `f(*args)` and the cache key to `args`.
4. Show it now works for `combinations_len(n, r)`.

**Note**: No need for `**kwargs` yet — keep it simple.

**Wrap-up**: “This decorator now works on most functions. Soon, we’ll make it work on *all* functions.”

---

## 🎥 Lesson 3. How to Benchmark Any Function

*(based on the updated `timed` decorator)*

**Goal**: Generalize the `timed` decorator to accept any kind of function.

**Concepts**:

* Combining `*args` and `**kwargs`
* Measuring time using `time.perf_counter()`

**Flow**:

1. Start with a basic `@timed` decorator.
2. Update the inner function to accept `*args, **kwargs`.
3. Show how to pass those on to `f(...)`.
4. Print both result and execution time.

**Bonus**: Mention that this is a common profiling trick.

---

## 🎥 Lesson 4. The Decorator Blueprint (Anatomy)

*(based on “Anatomy of a decorator”)*

**Goal**: Provide a reusable mental model for writing decorators.

**Concepts**:

* The typical structure of a decorator
* When and why to customize it

**Flow**:

1. Present the “blueprint” structure:

   ```python
   def decorator(f):
       def wrapper(*args, **kwargs):
           # pre-work
           result = f(*args, **kwargs)
           # post-work
           return result
       return wrapper
   ```
2. Map this back to `cache`, `timed`, and others.
3. Emphasize where you can plug in logic.
4. Mention that decorators can break these rules if needed — this is a *starting point*, not a constraint.

**Optional**: Show a version where the return value is modified.

---

## 🎥 Lesson 5. Common Pitfalls: Metadata Loss

**Goal**: Show how decorating a function can lose metadata like its name and docstring.

**Concepts**:

* Functions are objects
* `__name__`, `__doc__`

**Flow**:

1. Show a simple function with a name and docstring.
2. Decorate it with a do-nothing decorator.
3. Show that `__name__` and `__doc__` are now wrong/missing.
4. Emphasize: this happens whenever you replace a function with a wrapper.

**End note**: “There's a fix for this — and it’s also a decorator!”

---

## 🎥 Lesson 6. Fixing Metadata with `functools.wraps`

**Goal**: Introduce `wraps` and show how to use it properly.

**Concepts**:

* `@wraps(original_function)`
* Copying metadata

**Flow**:

1. Import and use `@wraps(f)` inside the wrapper.
2. Explain that `wraps(f)` returns a decorator you apply to the inner function.
3. Show that `__name__` and `__doc__` are now preserved.
4. Mention that `wraps` also helps with debugging, stack traces, and tooling.

**Warning**: “Don’t forget this! You’ll want it in most decorators you write.”

---

## 🎥 Lesson 7. Solve Together: Fix a Broken Decorator Without `wraps`

**Goal**: Reinforce the importance of `wraps` by fixing a broken example together.

**Flow**:

1. Show a decorator without `wraps` applied to a function.
2. Print `__name__`, `__doc__`, maybe even `help()`.
3. Add `@wraps` and confirm the fix.
4. Optionally: time it before and after, and show how logs/stack traces improve.

---

## 📘 Lesson 8. Exercise Break (self-guided)

**Goal**: Reinforce the full decorator blueprint, including variadic arguments and metadata preservation.

**Instructions**:

* Write a `@logger` decorator that prints arguments and return values.
* Write a `@safe` decorator that catches exceptions and returns a default value.
* Use `@wraps` in both cases.
* Test with functions that:

  * take multiple arguments
  * raise exceptions
  * return `None`, strings, etc.

**Bonus**: Stack `@timed` + `@logger` and describe the behavior.

---

## ✅ Section Summary

By the end of this section, the learner:

* Understands `*args` and `**kwargs` in decorators
* Can write fully general decorators
* Understands the standard “decorator blueprint”
* Knows when and why to use `functools.wraps`
* Can handle common real-world decorator needs

---

Would you like to adjust or add anything in this section, or should we move on to Section 4?
