# ‚öôÔ∏è Section 4 ‚Äì Customising Decorators with Arguments

**Target duration**: 60‚Äì75 minutes
**Purpose**: Teach learners how to write decorators that accept parameters, and explain the subtle syntax and logic involved in building decorator factories.
**Assumed knowledge**: Decorator blueprint with `*args`, `**kwargs`, and `@wraps`.

---

## üé• Lesson 1. Motivation: Customising a Cache‚Äôs Size

**Goal**: Introduce a real-world reason for wanting a parameterized decorator.

**Concepts**:

* Decorator configuration
* Cache size limits

**Flow**:

1. Recall the `@cache` decorator from earlier.
2. Pose the scenario: ‚ÄúWhat if we want to control the max number of cached values?‚Äù
3. Implement a fixed-size cache using `dict.popitem()` when over the limit.
4. Point out the hardcoded size (e.g., `1000`) and its limitations.

**Transition**: ‚ÄúWouldn‚Äôt it be better if we could write `@cache(1000)` instead?‚Äù

---

## üé• Lesson 2. The Problem with `@cache(1000)`

**Goal**: Help learners understand why a decorator with arguments can‚Äôt be written like a regular decorator.

**Concepts**:

* Syntax expectations for `@` in Python
* Function call vs decorator application

**Flow**:

1. Show attempts that don‚Äôt work:

   ```python
   @cache(1000)
   def f(...): ...
   ```

   when `cache` expects two arguments.
2. Explain: Python expects the result of `@something(...)` to be a *decorator*, not a function.
3. Introduce the concept of **two layers**:

   * Outer function: accepts arguments (e.g., `1000`)
   * Inner function: is the actual decorator

**Analogy**: ‚ÄúWe‚Äôre writing a factory that returns a decorator ‚Äî a decorator factory.‚Äù

---

## üé• Lesson 3. The Solution: A Decorator Factory

**Goal**: Implement a working decorator with arguments using nested functions.

**Concepts**:

* Closures again (to capture the decorator arguments)
* Returning functions from functions

**Flow**:

1. Implement:

   ```python
   def cache(maxsize):
       def decorator(f):
           ...
           return wrapper
       return decorator
   ```
2. Explain what happens at each level:

   * `cache(1000)` returns `decorator`
   * `@decorator` applies to the function
3. Show that this now works:

   ```python
   @cache(1000)
   def f(...): ...
   ```

**Tip**: Use `@wraps(f)` in the inner wrapper as before.

---

## üé• Lesson 4. Optional Arguments and Smart Decorators

*(based on ‚ÄúTo parens or not to parens?‚Äù)*

**Goal**: Show how to make decorators that optionally accept arguments, like `@lru_cache`.

**Concepts**:

* Type inspection
* Conditional logic to handle both use cases

**Flow**:

1. Show how `functools.lru_cache` supports:

   ```python
   @lru_cache
   @lru_cache()
   @lru_cache(512)
   ```
2. Walk through an implementation:

   ```python
   def cache(maxsize=1024):
       if callable(maxsize):
           # used as @cache
           return _cache(maxsize)
       else:
           # used as @cache(...)
           return lambda f: _cache(f, maxsize)
   ```
3. Explain why this works ‚Äî distinguish between a function being passed in vs a config value.

**Warning**: ‚ÄúThis is more advanced ‚Äî use it when flexibility is needed.‚Äù

---

## üìò Lesson 5. Exercise Break: Custom Cache with Max Size

**Instructions**:

* Re-implement `@cache(maxsize)` using nested functions.
* Cache should pop the oldest item when size limit is reached.
* Use a `list` or `collections.OrderedDict` to track item order if desired.
* Use `@wraps` as needed.
* Test on:

  * Fibonacci
  * Sin/cos
  * Any user-defined function

**Bonus**: Try allowing both `@cache` and `@cache(size)` syntax.

---

## üé• Lesson 6. Solve Together: Implement a Decorator with Arguments

**Goal**: Reinforce decorator factories by doing one together from scratch.

**Flow**:

1. Prompt: ‚ÄúLet‚Äôs build a decorator that repeats a function multiple times.‚Äù
2. Implement:

   ```python
   def repeat(n):
       def decorator(f):
           def wrapper(*args, **kwargs):
               for _ in range(n):
                   f(*args, **kwargs)
           return wrapper
       return decorator
   ```
3. Apply it to `say_hello()` and test.

**Optional**: Modify it to return the last result.

**Wrap-up**: ‚ÄúThis pattern unlocks even more power from decorators.‚Äù

---

## ‚úÖ Section Summary

By the end of this section, the learner:

* Understands how to write decorators that accept arguments
* Can build and apply decorator factories
* Knows the difference between decorators and decorator factories
* Has seen flexible patterns like optional parentheses

---

Ready to continue to Section 5 (Class-based decorators), or would you like to make any adjustments here first?
