# üß± Section 5 ‚Äì Class-Based Decorators

**Target duration**: 45‚Äì60 minutes
**Purpose**: Teach learners how to use classes to implement decorators, and when that is preferable to functions. Introduce the `__call__` method and the idea of attaching state and behavior to decorated functions.
**Assumed knowledge**: Full understanding of function-based decorators, including decorators with arguments.

---

### üé• Lesson 1. Functions Are Objects ‚Äì So Are Classes

**Goal**: Set the conceptual foundation for class-based decorators by recalling how decorators work and what Python calls during decoration.

**Concepts**:

* Functions are objects
* The `@decorator` syntax calls a *callable*
* Classes are callable via `__init__` + `__call__`

**Flow**:

1. Remind students: `@decorator` is sugar for `f = decorator(f)`
2. Show that *any* callable can be used as a decorator ‚Äî even a class.
3. Introduce the idea: if `MyDecorator` is a class, `@MyDecorator` means:

   ```python
   f = MyDecorator(f)
   ```

**Teaser**: ‚ÄúNow we‚Äôll write a class that behaves like a decorator function ‚Äî but gives us more control.‚Äù

---

### üé• Lesson 2. The Case for Class-Based Decorators

**Goal**: Explain when and why to use classes instead of functions for decorators.

**Concepts**:

* Mutable internal state
* Organizing behavior
* Cleaner APIs

**Flow**:

1. Show a function-based decorator that tracks `hits`, `misses`, or a cache.
2. Point out how messy it is to attach attributes to a function.
3. Contrast with a class where state is kept in `self`.

**Analogy**: ‚ÄúA function-based decorator is like a stateless tool. A class-based one can be a full-featured utility.‚Äù

**Wrap-up**: ‚ÄúLet‚Äôs write one!‚Äù

---

### üé• Lesson 3. Implementing a Class-Based Cache Decorator

*(based on ‚ÄúClasses as decorators‚Äù)*

**Goal**: Build a working example of a class-based decorator from scratch.

**Concepts**:

* `__init__` to receive the function
* `__call__` to run the function with optional logic
* `self.cache`, `self.hits`, etc.

**Flow**:

1. Define class `Cache`.
2. In `__init__`, store the function and initialize a cache dictionary.
3. In `__call__`, implement the caching logic.
4. Decorate a `fibonacci` function with `@Cache` and show that it works.

**Bonus**: Print the internal cache to show state is preserved in the object.

---

### üé• Lesson 4. Enhancing Decorated Functions with Attributes

**Goal**: Demonstrate the benefits of class-based decorators when attaching attributes or methods.

**Concepts**:

* Extending the API of a decorated function
* Self-contained decorators

**Flow**:

1. Add `hits` and `misses` tracking to the `Cache` class.
2. Add a method `clear_cache()`.
3. Show:

   ```python
   print(fib.hits)
   fib.clear_cache()
   ```
4. Emphasize: this is intuitive in a class, messy in a function.

**Caution**: ‚ÄúJust remember ‚Äî the result of `@Cache` is not a function. It‚Äôs a callable object.‚Äù

---

### üé• Lesson 5. Decorator Arguments + Classes = Clean Separation

**Goal**: Combine parameterization with class-based decorators.

**Concepts**:

* Passing arguments via outer factory
* Using `functools.partial` (lightly)

**Flow**:

1. Modify `Cache.__init__` to accept a `maxsize` parameter.
2. Implement a decorator factory:

   ```python
   def cache(maxsize):
       return lambda f: Cache(f, maxsize)
   ```
3. Or, use `functools.partial`:

   ```python
   return partial(Cache, maxsize=maxsize)
   ```
4. Apply with `@cache(1000)`.

**Bonus**: Briefly revisit the comparison to function-based factories ‚Äî this way is often cleaner when state is involved.

---

### üé• Lesson 6. Solve Together: `timed` as a Class-Based Decorator

**Goal**: Practice turning a known decorator into a class-based one.

**Flow**:

1. Define a `Timed` class.
2. Store the function in `__init__`.
3. Use `time.perf_counter()` in `__call__`.
4. Optionally:

   * Store timing history
   * Add an average time method

**Reflection**: ‚ÄúThis might be overkill for `timed`, but now you know when and how to do it.‚Äù

---

### üìò Lesson 7. Exercise Break (self-guided)

**Instructions**:

* Write a `@call_counter` class-based decorator that:

  * Tracks how many times a function is called
  * Adds a `.count` attribute
  * Adds a `.reset()` method
* Try combining it with other decorators (`@timed`, etc.)
* Compare behavior to function-based versions

**Bonus**: Support a threshold argument like `@call_counter(10)` to trigger a warning or message.

---

### ‚úÖ Section Summary

By the end of this section, the learner:

* Understands how classes can serve as decorators
* Can write decorators with internal state and methods
* Knows how to parameterize class-based decorators
* Can choose between function vs class decorators depending on needs

---

Would you like to go over or tweak anything here before we proceed to the final section (decorating classes)?
