# 🧑‍🏫 Section 6 – Decorating Classes

**Target duration**: 30–45 minutes
**Purpose**: Show that decorators can be applied to *classes*, not just functions. Provide compelling use cases and a practical example.
**Assumed knowledge**: Basic understanding of Python classes, including methods and attributes. Familiarity with function decorators.

---

## 🎥 Lesson 1. Yes, Classes Can Be Decorated Too

**Goal**: Make it clear that `@decorator` works with class definitions, and why that matters.

**Concepts**:

* The `@decorator` syntax is general-purpose
* A class definition is just another assignment

**Flow**:

1. Show:

   ```python
   @decorator
   class MyClass:
       ...
   ```

   is equivalent to:

   ```python
   class MyClass:
       ...
   MyClass = decorator(MyClass)
   ```
2. Emphasize: all the same rules apply — the decorator must accept the class and return a modified version of it.
3. Mention that standard library uses this: `@dataclass`, `@total_ordering`.

**End note**: “Let’s build a simple class decorator ourselves.”

---

## 🎥 Lesson 2. When to Use Class Decorators

**Goal**: Give learners practical reasons to decorate classes.

**Concepts**:

* Class transformation
* Reducing boilerplate
* Reusability of cross-cutting features

**Flow**:

1. Examples of orthogonal enhancements for classes:

   * Auto-generating `__repr__`
   * Validation
   * Registration systems (e.g. plugin registries)
2. Mention: class decorators are rarer than function decorators but very useful in libraries and frameworks.
3. Set up motivation for next lesson: auto-generating a `__repr__`.

---

## 🎥 Lesson 3. Solve Together: Implement an `@add_repr` Decorator

*(based on “Classes can be decorated”)*

**Goal**: Show learners how to write a simple, useful class decorator.

**Flow**:

1. Define a helper function:

   ```python
   def _general_repr(self):
       ...
   ```

   that returns a string like `ClassName(attr1=val1, attr2=val2)`
2. Define:

   ```python
   def add_repr(cls):
       cls.__repr__ = _general_repr
       return cls
   ```
3. Apply it to:

   * A `Person` class
   * A `Point3D` class
4. Show that now you get nice readable representations.

**Bonus tip**: Compare to `dataclasses.dataclass`.

**Closing idea**: “You’ve now seen decorators applied to functions, methods, and classes — anywhere there’s a name being defined, a decorator can hook in.”

---

## 📘 Lesson 4. Exercise Break (self-guided)

**Instructions**:

* Reimplement a simplified version of `@total_ordering`:

  * Add missing comparison methods to a class that defines `__lt__` and `__eq__`
* Create a `@auto_str` decorator that defines `__str__` based on the same logic as `__repr__`
* Optionally: make `@add_repr` configurable to use `__str__` instead of `__repr__`

**Bonus**: Research how `@dataclass` is implemented under the hood.

---

## ✅ Section Summary

By the end of this section, the learner:

* Understands how and why to decorate classes
* Can write a decorator that modifies class behavior
* Recognizes common built-in class decorators
* Can spot and understand class decorators in frameworks

---

Would you like to revise anything here, or are we ready to outline the final **wrap-up section**?
